# 软件工程

>* 软件工程定义、过程模型、敏捷、统一过程、成熟度
>
>* 需求工程:需求获取、需求变更、需求追踪
>
>* 系统设计:结构化设计、面向对象设计、人机界面设计等
>
>* 测试基础知识:测试方法、 测试阶段
>
>* 净室软件工程、基于构件的软件工程
>
>* 软件项目管理:进度、配置、质量、风险
>

## 过程模型

### 瀑布模型

特点：

* 严格区分阶段，**每个阶段因果关系紧密相连**
* 只适合**需求明确**的项目

缺点：

* 软件需求完整性、正确性难确定
* 严格串行化，**很长时间才能看到结果**
* **要求每个阶段一次性完全解决该阶段工作**，不显示

<img src="https://raw.githubusercontent.com/zpfate/ImageService/master/uPic/1741856366657" alt="image-20250313165924165" style="zoom:50%;" />

### 原型化模型

针对需求不明确的项目，做一个简易系统用来获取需求

原型模型两个阶段：

1. 原型开发阶段
2. 目标软件开发阶段

<img src="https://raw.githubusercontent.com/zpfate/ImageService/master/uPic/1741856408746" alt="image-20250313170006978" style="zoom:50%;" />



### 螺旋模型（原型+瀑布模型）

以快速原型为基础+瀑布模型

考虑了风险问题

<img src="https://raw.githubusercontent.com/zpfate/ImageService/master/uPic/1741856441537" alt="image-20250313170039825" style="zoom: 50%;" />

### V模型

测试贯穿于始终

测试分段，测试计划提前

<img src="https://cdn.jsdelivr.net/gh/zpfate/ImageService@master/uPic/1744639340.png" alt="image-20250414220218580" style="zoom:50%;" />

### W模型

测试和开发并行

<img src="https://cdn.jsdelivr.net/gh/zpfate/ImageService@master/uPic/1744639398.png" alt="image-20250414220317423" style="zoom:50%;" />

### 

### 构件组装模型

优点：易扩展、易重用、降低成本、安排任务更灵活

缺点：

* 构件设计要求经验丰富的架构师
* 设计不好的构件难重用
* 强调重用可能牺牲其他指标（如性能）
* 第三方构件质量难控制

示例：方舱医院、乐高积木

#### 基于构件的软件工程（CBSE）

CBSE体现了**购买而不是重新构造**的哲学

应该具备的特征：

* 可组装性：所有**外部交互**必须通过**公开定义的接口**进行
* 可部署性：构件总是二进制形式的，能作为一个独立实体在平台上运行
* 文档化： 用户根据文档来判断构件是否满足需求
* 独立性：可以在无其他特殊构件的情况下进行组装和部署
* 标准化：**符合某种标准化的构件模型**

<img src="https://cdn.jsdelivr.net/gh/zpfate/ImageService@master/uPic/1744639672.png" alt="image-20250414220750249" style="zoom:50%;" />

#### 构件的组装

一般都要借助胶水代码

1. 顺序组装：按顺序调用已经存在的构件
2. 层次组装：被调用构件提供接口必须和调用构件的请求**接口兼容**
3. 叠加组装：多个构件合并形成新构件，对外提供新的接口

组装可能出现3种不兼容：**参数不兼容、操作不兼容、操作不完备**



### 快速应用开发模型 （RAD）

<img src="https://cdn.jsdelivr.net/gh/zpfate/ImageService@master/uPic/1744640201.png" alt="image-20250414221640478" style="zoom:50%;" />



### 统一过程模型RUP

<img src="https://cdn.jsdelivr.net/gh/zpfate/ImageService@master/uPic/1744640255.png" alt="image-20250414221734551" style="zoom:50%;" />

### 敏捷方法

<img src="https://cdn.jsdelivr.net/gh/zpfate/ImageService@master/uPic/1744641032.png" alt="image-20250414223027406" style="zoom:50%;" />

* 极限编程 XP （Extreme Programing）

  > 4大价值观：
  >
  > 沟通 （加强面对面沟通）
  >
  > 简单（不过度设计）
  >
  > 反馈（及时反馈）
  >
  > 勇气（接受变更的勇气）

* 水晶系列方法：提倡机动性方法

* **Scrum 敏捷**：侧重于项目管理

* 特征驱动开发方法 (Feature Driven Development, FDD) 

  > 认为有效的软件开发需要3要素：**人、过程、技术**
  >
  > 定义6种关键的项目角色：项目经历、首席架构设计师、开发经理、主程序员、程序员和领域专家



### 软件能力成熟度模型 (Capability Maturity Model for Software, CMM) 

<img src="https://cdn.jsdelivr.net/gh/zpfate/ImageService@master/uPic/1744640323.png" alt="image-20250414221842630" style="zoom:50%;" />



## 逆向工程

<img src="https://cdn.jsdelivr.net/gh/zpfate/ImageService@master/uPic/1744641597.png" alt="image-20250414223954174" style="zoom:50%;" />

实现级：包括程序的**抽象语法树、符号表、过程**的设计表示

结构级：包括反映**程序分量之间相互依赖关系**的信息，例如调用图、结构图、程序和数据结构

功能级：包括反映**程序段功能及程序段**之间关系的信息，例如数据和控制流模型

领域级：包括反映程序分量或程序诸实体与**应用领域概念之间对应关系**的信息，例如实体关系型模型（**需求分析，ER模型，UML**）

<img src="https://cdn.jsdelivr.net/gh/zpfate/ImageService@master/uPic/1744641965.png" alt="image-20250414224603901" style="zoom:50%;" />



## 需求工程

软件需求包括 3 个不同的层次：业务需求、用户需求和功能需求（也包括非功能需求）。

<img src="https://cdn.jsdelivr.net/gh/zpfate/ImageService@master/uPic/1744642459.png" alt="image-20250414225413396" style="zoom:50%;" />

### 需求获取

<img src="https://cdn.jsdelivr.net/gh/zpfate/ImageService@master/uPic/1744810523.png" alt="image-20250416213512228" style="zoom:50%;" />

### 需求分析

<img src="https://cdn.jsdelivr.net/gh/zpfate/ImageService@master/uPic/1744810827.png" alt="image-20250416214025756" style="zoom:50%;" />

### 统一建模语言UML 

平台无关、语言无关

<img src="https://cdn.jsdelivr.net/gh/zpfate/ImageService@master/uPic/1744811360.png" alt="image-20250416214918664" style="zoom:50%;" />

### 需求变更管理过程

<img src="https://cdn.jsdelivr.net/gh/zpfate/ImageService@master/uPic/1744811976.png" alt="image-20250416215935520" style="zoom:50%;" />





## 软件系统建模

1. 结构化建模方法
2. 信息工程建模方法（或数据库建模方法）
3. 面向对象建模方法

## 系统设计

### 人机界面设计

* 置于用户控制之下

* 减少用户的记忆负担

* 保持界面的一致性

### 结构化设计

概要设计（外部设计）：功能需求分配给模块，确定每个模块的功能和**调用关系**，形成**模块结构图**

详细设计（内部设计）：为每个**具体任务**选择适当的技术手段和处理方法



### 结构化设计原则

* 模块独立性原则（**低耦合、高内聚**）
* 保持模块的大小适中
* 多扇入、少扇出
* 深度和宽度均不宜过高

<img src="/Users/twistedfate/Library/Application Support/typora-user-images/image-20250416221130713.png" alt="image-20250416221130713" style="zoom:50%;" />



<img src="https://cdn.jsdelivr.net/gh/zpfate/ImageService@master/uPic/1744812916.png" alt="image-20250416221513345" style="zoom:50%;" />



### 面向对象设计

#### 基本过程

<img src="https://raw.githubusercontent.com/zpfate/ImageService/master/uPic/1744968540153" alt="image-20250418172857283" style="zoom:50%;" />

#### 面向对象设计原则

 **SOLID 原则**：

* 单一职责原则**（SRP, Single Responsibility Principle）**：设计<font color=red>目的单一</font>的类

* 开放封闭原则**（OCP, Open-Closed Principle）**：对扩展开放，对<font color=red>修改封闭</font> 

* 李氏替换原则**（LSP, Liskov Substitution Principle）**：<font color=red>子类可以替换父类</font> 
* 接口隔离原则**（ISP, Interface Segregation Principle）**：使用多个专门的接口比使用单一的总接口要好
* 依赖倒置原则**（DIP, Dependency Inversion Principle）**：要依赖于抽象，而不是具体实现；<font color=red>针对接口编程</font> ，不要针对实现编程，依赖注入（DI）、控制反转（IoC）

**其他设计原则：**

* 组合重用原则：要<font color=red>尽量使用组合</font>，而不是继承
* 迪米特法则（最少知识原则）：一个对象应当对其他对象有<font color=red>尽可能少的了解</font>














## 系统分析与设计

### 结构化方法(SASD, Structured Analysis and Structured Design）

结构化开发方法提出了一组提高软件结构合理性的准则，如**分解与抽象、模块独立性、信息隐蔽**等。针对软件生存周期各个不同的阶段，它有**结构化分析（ SA) 、结构化设计 (SD) 和结构化编程 (SP)** 等方法。





## 软件测试

### 测试类型

#### 动态测试

依赖于计算机运行







软件测试方法的分类有很多种，以测试过程中程序执行状态为依据可分为**静态测试**（Static Testing, ST) 和**动态测试** (Dynamic Testing, DT) ;以具体实现算法细节和系统内部结构的相关情况为根据可分**黑盒测试**、**白盒测试**和**灰盒测试** 3 类；从程序执行的方式来分类，可分为**人工测试** (Manual Testing, MT) 和**自动化测试** (Automatic Testing, AT) 。

#### 静态测试

* 被测程序不运行

* 依靠分析或检查源程序的语句、结构、过程来检查是否有误，通过对软件的需求规格说明书、设计说明书以及源程序做结构分析和流程图分析（不匹配的参数，未定义的变量）

#### 动态测试

* 过运行被测试程序，对得到的运行结果与预期结构比较分析，同时分析运行效率和健壮性
* 简单分为三个步骤：**构造测试实例**、**执行程序**以及**分析结果**

#### 黑盒测试

将测试程序看成一个黑盒，不考虑内部结构和特性，根据需求规格说明书设计测试实例，并检查程序的功能是否运行的准确无误。

主要针对软件界面和功能进行测试。

对于黑盒测试必须加以量化才能够有效的保证软件的质量。

#### 白盒测试

借助陈谷内部的逻辑和相关信息，通过检测内部动作是否按照设计规格说明书的设定进行

是从程序结构方面出发对测试用例进行设计，用于检查逻辑结构是否合理，对应的模块独立路径是否正常以及内部结构是否有效。

常用的白盒测试法有**控制流分析、数据流分析、路径分析、程序变异**等。根据测试用例的覆盖程度，分为**语句覆盖、判定覆盖、分支覆盖**和**路径覆盖**等。

#### 灰盒测试

介于白盒和黑盒之间。除了重视输出相对于输入的正确性，也看重其内部的程序逻辑。

#### 自动化测试

软件测试的自动化。在预先设定的条件下自动运行被测程序，并分析运行结构。

### 测试阶段

从阶段上划分，软件测试可以分为单元测试、集成测试和系统测试，系统测试中又包含了

多种不同的测试种类，例如功能测试、性能测试、验收测试、压力测试等。

#### 单元测试

对该软件的模块进行测试，通过测试以发现该模块的功能不符合／不满足期望的情况和编码错误。

首先应该采用静态测试方法，比如静态分析、代码审查等

#### 集成测试

对已经严格按照程序设计要求和标准组装起来的模块同时进行测试，明确该程序结构组装的正确性，发现和接口有关的问题。

这阶段一般使用白盒测试和黑盒测试结合的方法进行测试，验证这一阶段设计的合理性以及需求功能的实现性。

#### 系统测试

一般情况系统测试采用黑盒测试，以此来检查该系统是否符合软件需求。

本阶段的主要测试内容包括功能性测试、性能测试、健壮性测试、安装或反安装测试、用户页面测试、压力测试、可靠性以及安全性测试等。

#### 性能测试

通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。负载测试和压力测试都属于性能测试。

#### 验收测试

最后一个阶段的测试，软件产品投入正式交付前的测试工作。





## 软件项目管理

### 概述

软件项目管理是为了使软件项目能够按照预定的成本、进度、质量顺利完成，而对人员(People) 、产品 (Product)、过程 (Process) 和项目 (Pro j ect)进行分析和管理的活动。

### 软件进度管理

所谓进度，指的是对执行活动和里程碑所制定的工作计划，而进度管理指的是为了确保项目按期完成所需要的管理过程。在软件进度管理过程中，一般包括：活动定义、活动排序、活动资源估计、活动历时估计、制定进度计划和进度控制。


### 软件质量管理

#### 软件质量保证(Software Q uality Assurance, SQA) 

软件质量保证的主要任务：

* SQA审计与评审
* SQA报告
* 处理不复核问题

#### 软件质量认证

目前国内软件企业主要采用的是 **ISO 9000** 和**能力成熟度模型 (Cap abi l ity Maturity Model, CMM)** 。

